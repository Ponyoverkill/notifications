# notifications

## configuration
- PORT=<порт на котором будет работать приложение>
- EMAIL=<тестовый email>
- DB_URI=<строка для подключения к mongoDB. Если mongoDb развернуто на localhost, используйте host.docker.internal вместо localhost>
- DB_NAME=<имя базы данных mongoDb>
- COLLECTION_NAME=<название коллекции пользователей>
- SMTP_HOST=<хост smtp сервера>
- SMTP_PORT=<порт smtp сервера>
- SMTP_LOGIN=<логин пользователя>
- SMTP_PASSWORD=<пароль пользователя>
- SMTP_EMAIL=<email с которого будет отправлено сообщение>
- SMTP_NAME=<Имя отображаемое у получателя письма>

- MAX_NOTIFICATIONS=<Максимальное число уведомлений у одного пользователя>

## startup

### build
находясь в дериктории проекта (cd {path_to_file}/notifications):
```shell
docker build -t <image_name> .
```
 - image_name - тег-имя, которое будет присвоено образу

Пример:
```shell
docker build -t notifications .
```

### run
#### Если mongoDb развернуто на localhost:
```shell
docker run --add-host host.docker.internal:host-gateway --env-file .env-non-dev -p <OUT_PORT>:<INNER_PORT> <image_name>
```
- image_name - тег-имя используемого образа (такое же, как и в пред. шаге). 
- OUT_PORT - внешний порт, через который можно подключиться к контейнеру.
- INNER_PORT - внутренний порт, указанный в конфигурационном файле, на котором развернуто приложение внутри контейнера

Теперь приложение доступно по адресу localhost:<OUT_PORT>, документация swagger доступна по адресу localhost:<OUT_PORT>/docs
Для других контейнеров приложение доступно по INNER_PORT

#### Пример:
```shell
docker run --add-host host.docker.internal:host-gateway --env-file .env-non-dev -p 8000:1234 notifications
```
доступно по localhost:8000


#### Если mongoDb развернуто не на localhost:
```shell
docker run --env-file .env-non-dev -p <OUT_PORT>:<INNER_PORT> <image_name>
```
- image_name - тег-имя используемого образа (такое же, как и в пред. шаге). 
- OUT_PORT - внешний порт, через который можно подключиться к контейнеру.
- INNER_PORT - внутренний порт, указанный в конфигурационном файле, на котором развернуто приложение внутри контейнера

Теперь приложение доступно по адресу localhost:<OUT_PORT>, документация swagger доступна по адресу localhost:<OUT_PORT>/docs
Для других контейнеров приложение доступно по INNER_PORT


#### Пример:
```shell
docker run --env-file .env-non-dev -p 8000:1234 notifications
```
доступно по localhost:8000

## На мое усмотрение
- Пришлось добавить поля в конфигурационный файл, т.к. я не знаю, как называется база данных и коллекция пользователей.
- Сервис писал из предположения, что у вас уже развернута готовая БД.
- Я не знаю, на каком хосте находится MongoDB (или возможно на том же хосте, но в контейнере), и на каком хосте будет тестироваться сервис, поэтому написал в инструкции, как стоит действовать.
- Сервис, запущенный в докере я тестировал с базой данных, развернутой на localhost, поэтому не уверен, что инструкции для запуска в остальных случаях работают.

## Подход к решению
Использовал FastAPI, т.к. чаще всего его использую.
При работе с БД в основном использовал агрегации.
За метку 'Запись прочитана' я принял поле 'is_new', указанное в тестовом задании.
Не особо понял, как именно развернуто MongoDB(Локально, удаленно, локально в контейнере)...